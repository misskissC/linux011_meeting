### 1 子进程创建的主要过程
(1) 执行`int 80h`指令进入系统调用`fork()`；

(2) `fork()`

[1] 为子进程搜索唯一进程号（PID）和空闲的进程管理结构体（PCB，包含TSS）；

[2] 继承父进程管理结构体部分属性，共享父进程下的全局数据（如文件），初始化子进程的TSS；计算子进程的逻辑内存空间，以设置子进程的LDT，并在GDT中设置子进程TSS和LDT的描述符；

[3] 为子进程分配页机制相关数据结构体（如页表目录项、页表和页表项）——映射为父进程的物理内存页（写时拷贝共享的物理内存页），刷新页机制数据结构体内存段在CPU中的快表（类似刷新cache）；

(3) 系统调用返回

### 2 进程调度主要过程
(1) CPU自动完成部分（比较复杂）

CPU在进行用户进程切换时大体会涉及以下过程。

[1] 根据欲切换进程的TSS选择符（如由跳转指令加载在CS中）在GDT中索引到目标TSS描述符，并进行一系列有效和权限检查；

[2] 保存当前进程的运行状态到其TSS（当前进程TSS地址保存在TR高32位中）；

[3] 将欲切换进程TSS描述符中的 地址和限长字段加载到TR高48位，将欲切换进程的TSS选择符加载到TR低16位；

[4] 根据欲切换进程TSS恢复欲切换进程的运行状态（各寄存器，如LDTR/CS/DS...）；

[5] 根据TSS恢复欲切进程运行状态后，CS/DS中的段选择符为`LDT描述符选择符`，该LDT的选择符在第[4]步中被加载到了LDTR中。CPU从GDT[LDTR]处获取到LDT在内存中的基址，进行一系列有效和权限检查后，CPU根据CS/DS在LDT中选择到对应的LDT描述符，并将其中基址和限长字段分别加载到CS/DS高的48位（同进程后续就不用再访问内存中的LDT了）。最后，根据CS/DS中的基址和EIP/ESI中的偏移地址 即可得到页转换之前的逻辑内存地址。
```C
           GDT
           +--------------+
  TSS   [1]|      ..      |
selector-->+--------------+
in CSS     |TSS descriptor| [2] backup current TSS
           +--------------| [3] load incoming TSS
           |      ..      |
  LDT   [4]+--------------+[5]
selector-->|LDT descriptor|--> LDT
in LDTR    +--------------+    +-----+
                            [6]|-----|
instr segment selector in CS-->+-----+[7]          [8]
                            [6]|     |--> CS + EIP --> logic mm addr
data  segment selector in DS-->+-----+[7]          [8]
                               |     |--> DS + ESI --> logic mm addr
                               +-----+
```

(2) 软件调度算法
见`8 进程调度`中的`调度策略`。

### 3 子进程创建和多进程调度开销分析
(1) 子进程创建开销分析

[1] 系统调用开销（见`9 系统调用开销`，但该版本不涉及对共享内核资源的等待）；

[2] PCB、页机制相关数据结构体（包括刷新快表）的读写操作。性能主要消耗在页表数据结构体的相关操作上。

(2) 多进程调度开销分析

[1] CPU自动完成部分主要包括对TSS的备份/恢复、CPU流水线刷新以及GDT/LDT的访问（GDT多次）；

[2] 多进程调度算法。

随着硬件性能增强和调度算法的演化，子进程创建和多进程调度开销都很小。像线程池这类编程方法并不是为了提升某次几十次的响应效率，而是为了总体（并发/积累）的时间性能。
