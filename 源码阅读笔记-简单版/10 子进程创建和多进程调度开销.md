### 1 子进程创建的主要过程
(1) 执行`int 80h`指令进入系统调用`fork()`；

(2) 系统调用`fork()`

[1] 为子进程搜索唯一进程号（PID）和空闲的进程管理结构体（PCB，包含TSS）；

[2] 继承父进程管理结构体部分属性，共享父进程涉及的全局数据（如文件），设置子进程的TSS；计算子进程的逻辑内存空间，设置子进程的LDT，在GDT中设置子进程TSS和LDT的描述符；

[3] 为子进程分配页表目录项、页表和页表项——映射为父进程的物理内存页（写时拷贝共享的物理内存页），刷新页机制在CPU中的快表（相当于刷新cache）；

(3) 系统调用返回

### 2 进程调度主要过程
(1) CPU自动完成部分
CPU在进行用户进程切换时大体会涉及以下过程。

[1] 根据欲切进程的TSS选择符在GDT中索引该TSS描述符，并进行一系列有效和权限检查；

[2] 保存当前进程的运行状态到其TSS（当前进程TSS地址保存在TR高32位中）；

[3] 将欲切进程TSS描述符中的地址和限长字段加载到TR高48位，将TSS选择符加载到TR低16位；

[4] 根据欲切进程TSS恢复欲切进程运行状态；

[5] 用户进程TSS中CS或DS中的选择符为LDT选择符，在执行指令和读取数据时会再次触发CPU在GDT中访问LDT，最终从相应LDT中获取到内存基址，再结合EIP或ESI中的偏移地址就得到了页转换之前的内存逻辑地址。
```C
           GDT
           +--------------+
  TSS   [1]|      ..      |
selector-->+--------------+
           |TSS descriptor|
           +--------------|
           |      ..      |
    CS  [4]+--------------+
selector-->|LDT descriptor|
           +--------------+
[2] backup current process states to its TSS
[3] load incoming process states from its TSS
[5] get the logic memory address according LDT.base_addr and eip
```

(2) 软件调度算法
见`8 进程调度`中的`调度策略`。

### 3 子进程创建和多进程调度开销分析
(1) 子进程创建开销分析

[1] 系统调用开销（见`9 系统调用开销`，但该版本不涉及对共享内核资源的等待）；

[2] PCB、页表项（更大）的设置，页表快表的刷新，这些都属于内存读写操作。性能主要消耗在页表数据结构体的相关操作上。

(2) 多进程调度开销分析

[1] CPU自动完成部分主要包括对TSS的备份/恢复以及CPU流水线刷新（GDT/LDT访问相对次要）；

[2] 多进程调度算法。

随着硬件性能增强和调度算法的演化，子进程创建和多进程调度开销都很小。像线程池这类编程方法并不是为了提升某次几十次的响应效率，而是为了总体（并发/积累）的时间性能。所以，考量使用线程池是否有必要是有必要的。