### 1 缓冲区位置
```C
+-------------+========+------------+-------------+
| OS routines | BUFFER | [RAM-DISK] | MAIN_MEMORY |
+-------------+========+------------+-------------+
0x0           end      4Mb                        16Mb
```
end 是操作系统内核程序内存段结束位置。linux0.11 引导程序为操作系统程序最大预留了512Kb 内存，可以将 512Kb 即 0x80000 作为 end 的参考值。

根据实模式内存分布, 缓冲区需除去内存段[0x9ffff, 0xfffff]即
```C
 0x00000|----------------------------------|
        |            1KB RAM               |
        | BIOS Interrupt vector table etc. |
 0x003FF|==================================|
        |                                  |
        |                                  |<-- end
        |             639KB                |
        |         RAM addr space           |
        |                                  |
        |                                  |
 0x9FFFF|==================================|
        |                                  |
        |              128K                |
        |    video card ram addr space     |
 0xBFFFF|==================================|
        |                                  |
        |             256KB                |
        |      BIOS ROM addr space         |
        |                                  |
        |                                  |
 0xFFFFF|==================================|
        |               .                  |
        |               .                  |
0x400000|               .                  |<-- 4Mb
```
即, 内存段[end, 0x400000)就是 linux0.11 设定缓冲区了。*/

### 2 缓冲区块
缓冲区被以缓冲区块为单位进行管理，每块大小为1024字节即1Kb.
```C
+-------------+----+-------------+
| buffer unit |... | buffer unit |
+-------------+----+-------------+
0                  x
```

### 3 缓冲区管理
[1] linux0.11 使用双向循环链表以1Kb为单位管理缓冲区;
[2] 为提高对缓冲区块访问的效率，使用 hash 表进一步管理缓冲区。
dev(设备号) ^ block(逻辑块号）相同者将使用同一个链表管理的缓冲区块，如
```C
0x301 ^ 0x000 = 0x301  0x302 ^ 0x000 = 0x302  ...
0x301 ^ 0x001 = 0x300  0x302 ^ 0x001 = 0x303  ...
0x301 ^ 0x002 = 0x303  0x302 ^ 0x002 = 0x300  ...
0x301 ^ 0x003 = 0x302  0x302 ^ 0x003 = 0x301  ...
0x301 ^ 0x004 = 0x305  0x302 ^ 0x004 = 0x306  ...
0x301 ^ 0x005 = 0x304  0x302 ^ 0x005 = 0x307  ...
0x301 ^ 0x006 = 0x307  0x302 ^ 0x006 = 0x304  ...
0x301 ^ 0x007 = 0x306  0x302 ^ 0x007 = 0x305  ...
0x301 ^ 0x008 = 0x309  0x302 ^ 0x008 = 0x30a  ...
0x301 ^ 0x009 = 0x308  0x302 ^ 0x009 = 0x30b  ...
0x301 ^ 0x00a = 0x30b  0x302 ^ 0x00a = 0x308  ...
```
可以看出，设备号为0x301上的逻辑块1与设备号为0x302上的逻辑块2将使用同一个hash值标识的循环链表（所管理的缓冲区块，若无则全局搜索并添加），而不用全局搜索缓冲区块。

读写诸如磁盘之类外设时都会借助于缓冲区：根据欲访问的设备和逻辑块号，获取空闲的缓冲区块，以缓冲区块大小为单位从磁盘读取数据到缓冲区操作，操作完毕后再同步到磁盘中（如释放，进程结束，读写完毕还未释放又被其它进程征用）。

当无缓冲区块可供当前进程用时，则设置该进程睡眠状态并主动切换其他进程运行（以释放缓冲区块）（linux 0.11内核不抢占），待该进程被唤醒且被调度时再继续运行。
